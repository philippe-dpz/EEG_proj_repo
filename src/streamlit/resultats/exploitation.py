import streamlit as st
import base64
import numpy as np
import matplotlib.pyplot as plt
import pickle
from math import radians, sin, cos

image_Path = "./assets/sessions/images/"
gif_size = 200


def read_gif(path: str):
    file = open(path, "rb")
    contents = file.read()
    result = base64.b64encode(contents).decode("utf-8")
    file.close()
    return result


class Session:
    def __init__(
        self,
        subjectNumber: int,
        sessionNumber: int,
        imgLeft: str,
        imgRight: str,
    ):
        self.subjectNumber = subjectNumber
        self.sessionNumber = sessionNumber
        self.imgLeft = read_gif(imgLeft)
        self.imgRight = read_gif(imgRight)

    def getLabel(self):
        return (
            "Sujet N° "
            + str(self.subjectNumber)
            + " Session N° "
            + str(self.sessionNumber)
        )

    def getLeftImage(self):
        return self.imgLeft

    def getRightImage(self):
        return self.imgRight


@st.cache_resource
def loadSessions():
    session = []
    subjectNumber = 0
    sessionNumber = 1
    for idx in range(0, 18):
        if sessionNumber != 2:
            subjectNumber += 1
        img = image_Path + "img" + str(idx) + "_"
        session.append(
            Session(
                subjectNumber,
                sessionNumber,
                img + "1" + ".gif",
                img + "2" + ".gif",
            )
        )
        if subjectNumber == 8 and sessionNumber == 2:
            session.append(
                Session(
                    subjectNumber,
                    3,
                    image_Path + "img18_1.gif",
                    image_Path + "img18_2.gif",
                )
            )
        if subjectNumber == 9 and sessionNumber == 2:
            session.append(
                Session(
                    subjectNumber,
                    3,
                    image_Path + "img19_1.gif",
                    image_Path + "img19_2.gif",
                )
            )
        sessionNumber = 2 if sessionNumber < 2 else 1
    return session


if "show_topomap" not in st.session_state:
    st.session_state["show_topomap"] = 0
if "nb_steps" not in st.session_state:
    st.session_state["nb_steps"] = 2


def create_path():
    st.session_state["path"] = np.random.choice(a=2, size=st.session_state.nb_steps)


def prepare_pred(y_test):
    y_test = [-1 if num == 2 else num for num in y_test]
    y_test = np.insert(y_test, 0, 0)
    return y_test


def compute_point(point_to_be_rotated, angle, center_point=(0, 0)):
    xnew = (
        cos(angle) * (point_to_be_rotated[0] - center_point[0])
        - sin(angle) * (point_to_be_rotated[1] - center_point[1])
        + center_point[0]
    )
    ynew = (
        sin(angle) * (point_to_be_rotated[0] - center_point[0])
        + cos(angle) * (point_to_be_rotated[1] - center_point[1])
        + center_point[1]
    )
    return xnew, ynew


def populate_graph_data(y_test):
    lst = [0, 1]
    y_test_ref = [0, 0]
    for ind, y in enumerate(y_test):
        if ind:
            lst[ind], y_test_ref[ind] = compute_point(
                (lst[ind], y_test_ref[ind]),
                18 if y > 0 else -18,
                (lst[ind - 1], y_test_ref[ind - 1]),
            )
            if ind < len(y_test) - 1:
                lst.append(lst[ind] + (lst[ind] - lst[ind - 1]))
                y_test_ref.append(
                    y_test_ref[ind] + (y_test_ref[ind] - y_test_ref[ind - 1])
                )
    return lst, y_test_ref


def graph(y_test):
    y_test = prepare_pred(y_test)
    X_, Y_ = populate_graph_data(y_test)
    fig = plt.figure(figsize=(10, 10))
    plt.plot(X_, Y_, "rv", linestyle="solid", label="temoin")
    plt.axis("off")
    plt.legend()
    st.pyplot(fig)


if "path" not in st.session_state:
    create_path()

st.markdown("# Exploitation")
st.markdown("Nous allons essayer d'utiliser les modèles construits avec la méthode 2.")
st.markdown(
    """<div style="text-align: justify;">
    Pour celà, nous tirons au hasard une suite de chiffres entre 1 et 2. Cette suite nous servira à tracer un parcours témoin, 1 signifie tourner à gauche, 2 tourner à droite.\
    <br>Quand il s'agit d'un changement de direction, nous tirons au hasard une tentative de la classe correspondante dans la session sélectionnée et nous la soumettons aux modèles. <br>Le résultat prédit sert à tracer le parcours.<br><br>""",
    unsafe_allow_html=True,
)

(
    col1,
    col2,
) = st.columns(2)
with col1:
    session = st.selectbox(
        "Choisissez une session :",
        loadSessions(),
        format_func=lambda session: session.getLabel(),
    )

    nb_steps = st.slider(
        "Nombre d'étapes dans le parcours :", min_value=5, max_value=50, step=1
    )

    nb_predic = st.slider(
        "Nombre de prédictions par décision :", min_value=1, max_value=51, step=2
    )

    if st.session_state.nb_steps != nb_steps:
        st.session_state.nb_steps = nb_steps
        create_path()

    st.session_state.show_topomap = (
        1
        if st.checkbox(
            "Afficher les topomaps",
            False,
        )
        else 0
    )

    if st.session_state.show_topomap:
        st.markdown(
            f'<div style="display: flex;justify-content: space-evenly;"><img src="data:image/gif;base64,{session.getLeftImage()}" style="height:{gif_size}px;" ><img src="data:image/gif;base64,{session.getRightImage()}" style="height:{gif_size}px;"></div>',
            unsafe_allow_html=True,
        )
with col2:
    graph(st.session_state.path)

st.button("Nouveau parcours", type="primary", on_click=create_path)
