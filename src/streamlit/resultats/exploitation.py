import streamlit as st
import base64
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle
from math import sin, cos

image_path = "./assets/sessions/images/"
data_path = "./assets/sessions/data/"
model_path = "./assets/models/"
gif_size = 200


def read_gif(path: str):
    file = open(path, "rb")
    contents = file.read()
    result = base64.b64encode(contents).decode("utf-8")
    file.close()
    return result


class Session:
    def __init__(
        self,
        subjectNumber: int,
        sessionNumber: int,
        imgLeft: str,
        imgRight: str,
        features: str,
        targets: str,
    ):
        self.subjectNumber = subjectNumber
        self.sessionNumber = sessionNumber
        self.imgLeft = read_gif(imgLeft)
        self.imgRight = read_gif(imgRight)
        features = pd.read_csv(features)
        self.features = features.drop(["Unnamed: 0"], axis=1)
        targets = pd.read_csv(targets)
        self.targets = targets.reset_index(drop=True)

    def getSubjectNumber(self):
        return self.subjectNumber

    def getSessionNumber(self):
        return self.sessionNumber

    def getLabel(self):
        return (
            "Sujet N° "
            + str(self.subjectNumber)
            + " Session N° "
            + str(self.sessionNumber)
        )

    def getLeftImage(self):
        return self.imgLeft

    def getRightImage(self):
        return self.imgRight

    def getFeatures(self):
        return self.features

    def getTargets(self):
        return self.targets

    def getNbTarget(self):
        return self.targets.shape[0]


@st.cache_resource
def logisticRegressionModel():
    return pickle.load(open(model_path + "LogisticRegression", "rb"))


@st.cache_resource
def adaBoostModel():
    return pickle.load(open(model_path + "AdaBoost", "rb"))


@st.cache_resource
def loadSessions():
    session = []
    img = image_path + "img" + "1" + "_"
    session.append(
        Session(
            1,
            1,
            img + "1" + ".gif",
            img + "2" + ".gif",
            data_path + "t" + ".csv",
            data_path + "y" + ".csv",
        )
    )
    return session


"""def loadSessions():
    session = []
    subjectNumber = 0
    sessionNumber = 1
    for idx in range(0, 18):
        if sessionNumber != 2:
            subjectNumber += 1
        img = image_path + "img" + str(idx) + "_"
        session.append(
            Session(
                subjectNumber,
                sessionNumber,
                img + "1" + ".gif",
                img + "2" + ".gif",
                data_path + "t" + str(idx) + ".csv",
                data_path + "y" + str(idx) + ".csv",
            )
        )
        if subjectNumber == 8 and sessionNumber == 2:
            session.append(
                Session(
                    subjectNumber,
                    3,
                    image_path + "img18_1.gif",
                    image_path + "img18_2.gif",
                    data_path + "t18.csv",
                    data_path + "y18.csv",
                )
            )
        if subjectNumber == 9 and sessionNumber == 2:
            session.append(
                Session(
                    subjectNumber,
                    3,
                    image_path + "img19_1.gif",
                    image_path + "img19_2.gif",
                    data_path + "t19.csv",
                    data_path + "y19.csv",
                )
            )
        sessionNumber = 2 if sessionNumber < 2 else 1

    return session
"""

if "show_topomap" not in st.session_state:
    st.session_state["show_topomap"] = 0
if "nb_steps" not in st.session_state:
    st.session_state["nb_steps"] = 2


def create_path():
    if "session" in st.session_state:
        st.session_state["path"] = random.sample(
            range(0, st.session_state.session.getNbTarget()),
            st.session_state.nb_steps,
        )


def prepare_pred(y_test):
    y_test = [-1 if num == 2 else num for num in y_test]
    y_test = np.insert(y_test, 0, 0)
    return y_test


def compute_point(point_to_be_rotated, angle, center_point=(0, 0)):
    xnew = (
        cos(angle) * (point_to_be_rotated[0] - center_point[0])
        - sin(angle) * (point_to_be_rotated[1] - center_point[1])
        + center_point[0]
    )
    ynew = (
        sin(angle) * (point_to_be_rotated[0] - center_point[0])
        + cos(angle) * (point_to_be_rotated[1] - center_point[1])
        + center_point[1]
    )
    return xnew, ynew


def populate_graph_data(y_test):
    lst = [0, 1]
    y_test_ref = [0, 0]
    for ind, y in enumerate(y_test):
        if ind:
            lst[ind], y_test_ref[ind] = compute_point(
                (lst[ind], y_test_ref[ind]),
                0.15 if y > 0 else -0.15,
                (lst[ind - 1], y_test_ref[ind - 1]),
            )
            if ind < len(y_test) - 1:
                lst.append(lst[ind] + (lst[ind] - lst[ind - 1]))
                y_test_ref.append(
                    y_test_ref[ind] + (y_test_ref[ind] - y_test_ref[ind - 1])
                )
    return lst, y_test_ref

def graph(path):
    session = st.session_state.session

    y_test = session.getTargets().iloc[path]["eventType"]
    y_test = prepare_pred(y_test)

    X_, Y_ = populate_graph_data(y_test)

    fig = plt.figure(figsize=(10, 10))
    plt.plot(X_, Y_, "rv", linestyle="solid", label="temoin")

    X_test = session.getFeatures().iloc[path]
    y_pred_ada = adaBoostModel().predict(X_test)
    y_pred_ada = [int(num) for num in y_pred_ada]
    y_pred_ada = prepare_pred(y_pred_ada)
    Xada_, Yada_ = populate_graph_data(y_pred_ada)
    plt.plot(Xada_, Yada_, "g1", linewidth=0.5, linestyle="solid", label="Ada")

    y_pred_lg = logisticRegressionModel().predict(X_test)
    y_pred_lg = [int(num) for num in y_pred_lg]
    y_pred_lg = prepare_pred(y_pred_lg)
    Xlg_, Ylg_ = populate_graph_data(y_pred_lg)
    plt.plot(Xlg_, Ylg_, "b3", linewidth=0.5, linestyle="solid", label="Lg")

    plt.axis("off")
    plt.legend()
    st.pyplot(fig)

st.markdown("# Exploitation")
st.markdown("Nous allons essayer d'utiliser les modèles construits avec la méthode 2.")
st.markdown(
    """<div style="text-align: justify;">
    Pour celà, nous tirons au hasard une suite de chiffres entre 1 et 2. Cette suite nous servira à tracer un parcours témoin, 1 signifie tourner à gauche, 2 tourner à droite.\
    <br>Quand il s'agit d'un changement de direction, nous tirons au hasard une tentative de la classe correspondante dans la session sélectionnée et nous la soumettons aux modèles. <br>Le résultat prédit sert à tracer le parcours.<br><br>""",
    unsafe_allow_html=True,
)

(
    col1,
    col2,
) = st.columns(2)
with col1:
    session = st.selectbox(
        "Choisissez une session :",
        loadSessions(),
        format_func=lambda session: session.getLabel(),
    )
    if "session" not in st.session_state:
        st.session_state["session"] = session
        create_path()
    else:
        oldSession = st.session_state["session"]
        if (
            session.getSubjectNumber() != oldSession.getSubjectNumber()
            or session.getSessionNumber() != oldSession.getSessionNumber()
        ):
            st.session_state["session"] = session
            create_path()

    nb_steps = st.slider(
        "Nombre d'étapes dans le parcours :", min_value=5, max_value=50, step=1
    )

    if st.session_state.nb_steps != nb_steps:
        st.session_state.nb_steps = nb_steps
        create_path()

    st.session_state.show_topomap = (
        1
        if st.checkbox(
            "Afficher les topomaps",
            False,
        )
        else 0
    )

    if st.session_state.show_topomap:
        st.markdown(
            f'<div style="display: flex;justify-content: space-evenly;"><img src="data:image/gif;base64,{session.getLeftImage()}" style="height:{gif_size}px;" ><img src="data:image/gif;base64,{session.getRightImage()}" style="height:{gif_size}px;"></div>',
            unsafe_allow_html=True,
        )
with col2:
    graph(st.session_state.path)

st.button("Nouveau parcours", type="primary", on_click=create_path)
