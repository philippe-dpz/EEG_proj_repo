import streamlit as st
import base64
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle
from math import sin, cos

image_path = "./assets/sessions/images/"
data_path = "./assets/sessions/sdata/"
model_path = "./assets/models/"
gif_size = 200


def read_gif(path: str):
    file = open(path, "rb")
    contents = file.read()
    result = base64.b64encode(contents).decode("utf-8")
    file.close()
    return result


class Session:
    def __init__(
        self,
        subjectNumber: int,
        sessionNumber: int,
        imgLeft: str,
        imgRight: str,
        features: pd.DataFrame,
        targets: pd.DataFrame,
    ):
        self.subjectNumber = subjectNumber
        self.sessionNumber = sessionNumber
        self.imgLeft = read_gif(imgLeft)
        self.imgRight = read_gif(imgRight)
        self.features = features.drop(["Unnamed: 0"], axis=1)
        self.targets = targets

    def getSubjectNumber(self):
        return self.subjectNumber

    def getSessionNumber(self):
        return self.sessionNumber

    def getLabel(self):
        return (
            "Sujet N° "
            + str(self.subjectNumber)
            + " Session N° "
            + str(self.sessionNumber)
        )

    def getLeftImage(self):
        return self.imgLeft

    def getRightImage(self):
        return self.imgRight

    def getFeatures(self):
        return self.features

    def getTargets(self):
        return self.targets

    def getNbTarget(self):
        return self.targets.shape[0]


@st.cache_resource
def logisticRegressionModel():
    return pickle.load(open(model_path + "LogisticRegression", "rb"))


@st.cache_resource
def adaBoostModel():
    return pickle.load(open(model_path + "AdaBoost", "rb"))


@st.cache_resource
def randomForestClassifier():
    return pickle.load(open(model_path + "RandomForestClassifier", "rb"))


@st.cache_resource
def loadSessions():
    session = []
    sessionXTest = pd.read_csv(data_path + "Xtest.csv")
    sessionYTest = pd.read_csv(data_path + "Ytest.csv")
    img = image_path + "img" + "1" + "_"
    session.append(
        Session(
            8,
            3,
            img + "1" + ".gif",
            img + "2" + ".gif",
            sessionXTest.head(int(len(sessionXTest) / 2)),
            sessionYTest.head(int(len(sessionYTest) / 2)),
        )
    )
    session.append(
        Session(
            9,
            3,
            img + "1" + ".gif",
            img + "2" + ".gif",
            sessionXTest.tail(int(len(sessionXTest) / 2)),
            sessionYTest.tail(int(len(sessionYTest) / 2)),
        )
    )
    sessionXUTest = pd.read_csv(data_path + "XUntrainTest.csv")
    sessionYUTest = pd.read_csv(data_path + "YUntrainTest.csv")
    min = 0
    step = 120
    for idx in range(1, 10):
        if idx == 8:
            step = 160
        else:
            step = 120    
        session.append(
            Session(
                idx,
                1,
                img + "1" + ".gif",
                img + "2" + ".gif",
                sessionXUTest.iloc[min:min + step],
                sessionYUTest.iloc[min:min + step],
            )
        )
        min += step
        if idx == 4 or idx == 5:
            step = 140
        else:
            step = 120
        session.append(
            Session(
                idx,
                2,
                img + "1" + ".gif",
                img + "2" + ".gif",
                sessionXUTest.iloc[min:min + step],
                sessionYUTest.iloc[min:min + step],
            )
        )
        min += step

    return session

if "show_topomap" not in st.session_state:
    st.session_state["show_topomap"] = 0
if "nb_steps" not in st.session_state:
    st.session_state["nb_steps"] = 2


def create_path():
    if "session" in st.session_state:
        st.session_state["path"] = random.sample(
            range(0, st.session_state.session.getNbTarget()),
            st.session_state.nb_steps,
        )


def prepare_pred(y_test):
    y_test = [-1 if num == 2 else num for num in y_test]
    y_test = np.insert(y_test, 0, 0)
    return y_test


def compute_point(point_to_be_rotated, angle, center_point=(0, 0)):
    xnew = (
        cos(angle) * (point_to_be_rotated[0] - center_point[0])
        - sin(angle) * (point_to_be_rotated[1] - center_point[1])
        + center_point[0]
    )
    ynew = (
        sin(angle) * (point_to_be_rotated[0] - center_point[0])
        + cos(angle) * (point_to_be_rotated[1] - center_point[1])
        + center_point[1]
    )
    return xnew, ynew


def populate_graph_data(y_test):
    lst = [0, 1]
    y_test_ref = [0, 0]
    for ind, y in enumerate(y_test):
        if ind:
            lst[ind], y_test_ref[ind] = compute_point(
                (lst[ind], y_test_ref[ind]),
                0.02 if y > 0 else -0.02,
                (lst[ind - 1], y_test_ref[ind - 1]),
            )
            if ind < len(y_test) - 1:
                lst.append(lst[ind] + (lst[ind] - lst[ind - 1]))
                y_test_ref.append(
                    y_test_ref[ind] + (y_test_ref[ind] - y_test_ref[ind - 1])
                )
    return lst, y_test_ref


def graph(path):
    session = st.session_state.session

    y_test = session.getTargets().iloc[path]["eventType"]
    y_test = prepare_pred(y_test)

    X_, Y_ = populate_graph_data(y_test)

    fig = plt.figure(figsize=(10, 10))
    plt.plot(X_, Y_, "rv", linestyle="solid", label="temoin")

    X_test = session.getFeatures().iloc[path]
    y_pred_ada = adaBoostModel().predict(X_test)
    y_pred_ada = [int(num) for num in y_pred_ada]
    y_pred_ada = prepare_pred(y_pred_ada)
    Xada_, Yada_ = populate_graph_data(y_pred_ada)
    plt.plot(Xada_, Yada_, "g1", linewidth=0.5, linestyle="solid", label="Ada")

    y_pred_lg = logisticRegressionModel().predict(X_test)
    y_pred_lg = [int(num) for num in y_pred_lg]
    y_pred_lg = prepare_pred(y_pred_lg)
    Xlg_, Ylg_ = populate_graph_data(y_pred_lg)
    plt.plot(Xlg_, Ylg_, "b3", linewidth=0.5, linestyle="dotted", label="Lg")

    y_pred_f = randomForestClassifier().predict(X_test)
    y_pred_f = [int(num) for num in y_pred_f]
    y_pred_f = prepare_pred(y_pred_f)
    Xf_, Yf_ = populate_graph_data(y_pred_f)

    plt.plot(Xf_, Yf_, "y4", linewidth=0.5, linestyle="dashed", label="Forest")
    y_pred_m = np.mean([y_pred_ada, y_pred_lg, y_pred_f], axis=0)
    y_pred_m = [0 if num == 0 else -1 if num < 0 else 1 for num in y_pred_m]
    Xm_, Ym_ = populate_graph_data(y_pred_m)
    plt.plot(Xm_, Ym_, "c2", linewidth=0.5, linestyle="dashdot", label="Majorité")

    plt.axis("off")
    plt.legend()
    st.pyplot(fig)


st.markdown("# Exploitation")
st.markdown("Nous allons essayer d'utiliser les modèles construits avec la méthode 2.")
st.markdown(
    """<div style="text-align: justify;">
    Pour celà, nous tirons au hasard une suite de chiffres entre 1 et 2. Cette suite nous servira à tracer un parcours témoin, 1 signifie tourner à gauche, 2 tourner à droite.\
    <br>Quand il s'agit d'un changement de direction, nous tirons au hasard une tentative de la classe correspondante dans la session sélectionnée et nous la soumettons aux modèles. <br>Le résultat prédit sert à tracer le parcours.<br><br>""",
    unsafe_allow_html=True,
)

(
    col1,
    col2,
) = st.columns(2)
with col1:
    session = st.selectbox(
        "Choisissez une session :",
        loadSessions(),
        format_func=lambda session: session.getLabel(),
    )
    if "session" not in st.session_state:
        st.session_state["session"] = session
        create_path()
    else:
        oldSession = st.session_state["session"]
        if (
            session.getSubjectNumber() != oldSession.getSubjectNumber()
            or session.getSessionNumber() != oldSession.getSessionNumber()
        ):
            st.session_state["session"] = session
            create_path()

    nb_steps = st.slider(
        "Nombre d'étapes dans le parcours :", min_value=5, max_value=50, step=1
    )

    if st.session_state.nb_steps != nb_steps:
        st.session_state.nb_steps = nb_steps
        create_path()

    st.session_state.show_topomap = (
        1
        if st.checkbox(
            "Afficher les topomaps",
            False,
        )
        else 0
    )

    if st.session_state.show_topomap:
        st.markdown(
            f'<div style="display: flex;justify-content: space-evenly;"><img src="data:image/gif;base64,{session.getLeftImage()}" style="height:{gif_size}px;" ><img src="data:image/gif;base64,{session.getRightImage()}" style="height:{gif_size}px;"></div>',
            unsafe_allow_html=True,
        )
with col2:
    graph(st.session_state.path)

st.button("Nouveau parcours", type="primary", on_click=create_path)
